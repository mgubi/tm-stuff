/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/torus.js":
/*!**********************!*\
  !*** ./src/torus.js ***!
  \**********************/
/***/ ((module) => {

eval("// @begindebug\n//> These utility functions enable rich debugging statements\n//  during development, when using the development build\n//  (`dist/torus.dev.js`). These give you hierarchical information\n//  about what components are being rendered, and how.\n\n//> Flag to enable rich debugging during renders\nconst DEBUG_RENDER = true;\n\n//> Repeat a string `count` times. Used to indent in `render_debug`.\nconst repeat = (str, count) => {\n    let s = '';\n    while (count -- > 0) {\n        s += str;\n    }\n    return s;\n}\n\n//> Main rich debug logger function. `render_debug()` depends on\n//  the `render_stack` counter in our rendering algorithm to\n//  figure out how deep in the render tree we are, and indent\n//  the message to the level appropriate to our place in the\n//  render tree.\nconst render_debug = (msg, header = false) => {\n    if (DEBUG_RENDER) {\n        if (header) {\n            //> We want to pull forward headers in front\n            //  of their section contents, so we de-indent 1.\n            const prefix = repeat('\\t', render_stack - 1);\n            console.log('%c' + prefix + msg, 'font-weight: bold');\n        } else {\n            const prefix = repeat('\\t', render_stack);\n            console.log(prefix + msg);\n        }\n    }\n}\n\n//> Helper function for debugging logs where we want to print\n//  a JDOM node in the most appropriate way, depending on type.\nconst printNode = node => {\n    if (node === null) {\n        return '<!---->';\n    } else if (node.tag) {\n        return `<${node.tag.toLowerCase()}>`;\n    } else if (node.tagName) {\n        return `<${node.tagName.toLowerCase()}>`;\n    } else if (typeof node === 'string' || typeof node === 'number') {\n        return `\"${node}\"`;\n    } else if (node.nodeType === 3) {\n        return `text node \"${node.data}\"`;\n    }\n    return node.toString();\n}\n\n// @enddebug\n\n//> A global counter for how deep we are in our render tree.\n//  0 indicates that we aren't in the middle of rendering.\nlet render_stack = 0;\n\n//> Shortcut utility function to check if a given name is\n//  bound to something that's an actual object (not just null).\n//  We perform the `null` check first because that's faster.\nconst isObject = obj => obj !== null && typeof obj === 'object';\n\n//> `normalizeJDOM` takes a JDOM object (dictionary) and modifies\n//  it in place so it has the default JDOM properties, and we don't\n//  have to complicate our rendering code by checking for nulls with\n//  every key access into our serialized virtual DOM.\n//  Note that we don't check `isObject(jdom)` here. We assume\n//  only valid objects are passed in to 'normalize', which is true\n//  in our usage so far. `normalizeJDOM` is a hot path in rendering,\n//  so we need it as fast as it can be.\nconst normalizeJDOM = jdom => {\n    if (jdom.attrs === undefined) {\n        jdom.attrs = {};\n    }\n    if (jdom.events === undefined) {\n        jdom.events = {};\n    }\n    if (jdom.children === undefined) {\n        jdom.children = [];\n    }\n}\n\n//> Quick shorthand to normalize either 1. a single value or 2. an array\n//  of values into an array of values. This is useful because JDOM\n//  accepts either into things like `attrs.class` and `events.<name>`.\nconst arrayNormalize = data => Array.isArray(data) ? data : [data];\n\n//> We use comment nodes as placeholder nodes because they're lightweight\n//  and invisible.\nconst tmpNode = () => document.createComment('');\n\n//> `opQueue` is a global queue of node-level operations to be performed.\n//  These are calculated during the diff, but because operations touching the\n//  page DOM are expensive, we defer them until the end of a render pass\n//  and run them all at once, asynchronously. Each item in the queue is an array\n//  that starts with an opcode (one of the three below), and is followed\n//  by the list of arguments the operation takes. We render all operations in the queue\n//  to the DOM before the browser renders the next frame.\nlet opQueue = [];\nconst OP_APPEND = 0; // append, parent, new\nconst OP_REMOVE = 1; // remove, parent, old\nconst OP_REPLACE = 2; // replace, old, new\n//> This is a stubbed `parentNode`. See below in `runDOMOperations` for why this exists.\nconst STUB_PARENT = {\n    replaceChild: () => {},\n};\n\n//> `runDOMOperations` works through the `opQueue` and performs each\n//  DOM operation in order they were queued. rDO is called when the reconciler\n//  (`render`) reaches the bottom of a render stack (when it's done reconciling\n//  the diffs in a root-level JDOM node of a component).\nfunction runDOMOperations() {\n    //> This function is written to avoid any potential reconciliation conflicts.\n    //  There are two risks to mitigate: 1. attempting insert a node\n    //  that is already in the DOM, and 2. attempting remove a node that isn't\n    //  in the DOM. Both will result in inconsistent DOM state and break the renderer.\n    //  To avoid this, first, we remove all children and add placeholders where they\n    //  ought to be replaced. Then, in a second loop, we add any children that need\n    //  to be added and replace placeholders. Thus, no children will be inadvertently removed\n    //  and no wrong node will be removed.\n    const len = opQueue.length;\n    for (let i = 0; i < len; i ++) {\n        const next = opQueue[i];\n        const op = next[0];\n        if (op === OP_REMOVE) {\n            //> Remove all children that should be\n            next[1].removeChild(next[2]);\n        } else if (op === OP_REPLACE) {\n            //> For the ones queued to for being replaced,\n            //  put in a placeholder node, and queue that up instead.\n            const oldNode = next[1];\n            const tmp = tmpNode();\n            const parent = oldNode.parentNode;\n            //> Sometimes, the given node will be a standalone node\n            //  (like the root of an unmounted component) and will have no `parentNode`.\n            //  In these rare cases, it's best for performance to just set the parent to a stub\n            //  with a no-op `replaceChild`. Trying to check for edge cases later each time is a\n            //  performance penalty, since this is a very rare case.\n            if (parent !== null) {\n                parent.replaceChild(tmp, oldNode);\n                next[1] = tmp;\n                next[3] = parent;\n            } else {\n                next[3] = STUB_PARENT;\n            }\n        }\n    }\n    for (let i = 0; i < len; i ++) {\n        const next = opQueue[i];\n        const op = next[0];\n        if (op === OP_APPEND) {\n            //> Add any node that need to be added\n            next[1].appendChild(next[2]);\n        } else if (op === OP_REPLACE) {\n            //> Replace placeholders with correct nodes. This is\n            // equivalent to `parent.replaceChild(newNode, oldNode)`\n            next[3].replaceChild(next[2], next[1]);\n        }\n    }\n    opQueue = [];\n}\n\n//> A function to compare event handlers in `render`\nconst diffEvents = (whole, sub, cb) => {\n    for (const eventName of Object.keys(whole)) {\n        const wholeEvents = arrayNormalize(whole[eventName]);\n        const subEvents = arrayNormalize(sub[eventName] || []);\n        for (const handlerFn of wholeEvents) {\n            //> Sometimes, it's nice to be able to pass in non-function values to event\n            //  objects in JDOM, because we may be toggling the presence of an event listener\n            //  with a ternary expression, for example. We only attach function handlers here.\n            if (!subEvents.includes(handlerFn) && typeof handlerFn === 'function') {\n                cb(eventName, handlerFn);\n            }\n        }\n    }\n}\n\n//> Torus's virtual DOM rendering algorithm that manages all diffing,\n//  updating, and efficient DOM access. `render` takes `node`, the previous\n//  root node; `previous`, the previous JDOM; and `next`, the new JDOM;\n//  and returns the new root node (potentially different from the old\n//  root node.) Whenever a component is rendered, it calls `render`. This\n//  rendering algorithm is recursive into child nodes. Despite not touching\n//  the DOM, this is still one of the most expensive parts of rendering.\nconst render = (node, previous, next) => {\n\n    //> This queues up a node to be inserted into a new slot in the\n    //  DOM tree. All queued replacements will flush to DOM at the end\n    //  of the render pass, from `runDOMOperations`.\n    const replacePreviousNode = newNode => {\n        if (node && node !== newNode) {\n            opQueue.push([OP_REPLACE, node, newNode]);\n        }\n        node = newNode;\n    };\n\n    //> We're rendering a new node in the render tree. Increment counter.\n    render_stack ++;\n\n    //> We only do diff operations if the previous and next items are not the same.\n    if (previous !== next) {\n        //> If we need to render a null (comment) node,\n        //  create and insert a comment node. This might seem\n        //  silly, but it keeps the DOM consistent between\n        //  renders and makes diff simpler.\n        if (next === null) {\n            // @begindebug\n            if (node === undefined) {\n                render_debug('Add comment node');\n            } else {\n                render_debug(`Replace previous node ${printNode(previous)} with comment node`);\n            }\n            // @enddebug\n            replacePreviousNode(tmpNode());\n        //> If we're rendering a string or raw number,\n        //  convert it into a string and add a TextNode.\n        } else if (typeof next === 'string' || typeof next === 'number') {\n            // @begindebug\n            if (node === undefined) {\n                render_debug(`Add text node \"${next}\"`);\n            } else {\n                render_debug(`Replace previous node ${printNode(previous)} with text node \"${next}\"`);\n            }\n            // @enddebug\n            //> If the previous node was also a text node, just replace the `.data`, which is\n            //  very fast (as of 5/2019 faster than `.nodeValue`, `.textContent`, and .`innerText`). Otherwise, create a new `TextNode`.\n            if (typeof previous === 'string' || typeof previous === 'number') {\n                node.data = next;\n            } else {\n                replacePreviousNode(document.createTextNode(next));\n            }\n        //> If we need to render a literal DOM Node, just replace\n        //  the old node with the literal node.\n        } else if (next.appendChild !== undefined) { // check if next instanceof Node; fastest way is checking for presence of a non-getter property\n            // @begindebug\n            if (node === undefined) {\n                render_debug(`Add literal element ${printNode(next)}`);\n            } else {\n                render_debug(`Replace literal element ${printNode(previous)} with literal element ${printNode(next)}`);\n            }\n            // @enddebug\n            replacePreviousNode(next);\n        //> If we're rendering an object literal, assume it's a serialized\n        //  JDOM dictionary. This is the meat of the algorithm.\n        } else { // next is a non-null object\n            // @debug\n            render_debug(`Render pass for <${next.tag}>:`, true);\n\n            if (\n                node === undefined\n                || !isObject(previous)\n                //> Check if previous instanceof Node; fastest way is checking for presence of a\n                //  non-getter property, like `appendChild`.\n                || (previous && previous.appendChild !== undefined)\n                //> If the tags differ, we assume the subtrees will be different\n                //  as well and just start a completely new element. This is efficient\n                //  in practice, reduces the time complexity of the algorithm, and\n                //  an optimization shared with React's reconciler.\n                || previous.tag !== next.tag\n            ) {\n                // @begindebug\n                if (node === undefined) {\n                    render_debug(`Add <${next.tag}>`);\n                } else {\n                    render_debug(`Replace previous node ${printNode(previous)} with <${next.tag}>`);\n                }\n                // @enddebug\n                //> If the previous JDOM doesn't exist or wasn't JDOM, we're adding a completely\n                //  new node into the DOM. Stub an empty `previous`.\n                previous = {\n                    tag: null,\n                };\n                replacePreviousNode(document.createElement(next.tag));\n            }\n            normalizeJDOM(previous);\n            normalizeJDOM(next);\n\n            //> Compare and update attributes\n            for (const attrName of Object.keys(next.attrs)) {\n                const pAttr = previous.attrs[attrName];\n                const nAttr = next.attrs[attrName]\n\n                if (attrName === 'class') {\n                    //> JDOM can pass classes as either a single string\n                    //  or an array of strings, so we need to check for either\n                    //  of those cases.\n                    const nextClass = nAttr;\n                    //> Mutating `className` is faster than iterating through\n                    //  `classList` objects if there's only one batch operation\n                    //  for all class changes.\n                    if (Array.isArray(nextClass)) {\n                        // @begindebug\n                        if (node.className !== nextClass.join(' ')) {\n                            render_debug(`Update class names for <${next.tag}> to \"${nextClass.join(' ')}\"`);\n                        }\n                        // @enddebug\n                        node.className = nextClass.join(' ');\n                    } else {\n                        // @begindebug\n                        if (node.className !== nextClass) {\n                            render_debug(`Update class name for <${next.tag}> to ${nextClass}`);\n                        }\n                        // @enddebug\n                        node.className = nextClass;\n                    }\n                } else if (attrName === 'style') {\n                    //> JDOM takes style attributes as a dictionary\n                    //  rather than a string for API ergonomics, so we serialize\n                    //  it differently than other attributes.\n                    const prevStyle = pAttr || {};\n                    const nextStyle = nAttr;\n\n                    //> When we iterate through the key/values of a flat object like this,\n                    //  you may be tempted to use `Object.entries()`. We use `Object.keys()` and lookups,\n                    //  which is less idiomatic, but fast. This results in a measurable performance bump.\n                    for (const styleKey of Object.keys(nextStyle)) {\n                        if (nextStyle[styleKey] !== prevStyle[styleKey]) {\n                            // @debug\n                            render_debug(`Set <${next.tag}> style ${styleKey}: ${nextStyle[styleKey]}`);\n                            node.style[styleKey] = nextStyle[styleKey];\n                        }\n                    }\n                    for (const styleKey of Object.keys(prevStyle)) {\n                        if (nextStyle[styleKey] === undefined) {\n                            // @debug\n                            render_debug(`Unsetting <${next.tag}> style ${styleKey}: ${prevStyle[styleKey]}`);\n                            node.style[styleKey] = '';\n                        }\n                    }\n                //> If an attribute is an IDL attribute, we set it\n                //  through JavaScript properties on the HTML element\n                //  and not `setAttribute()`. This is necessary for\n                //  properties like `value` and `indeterminate`.\n                } else if (attrName in node) {\n                    // @debug\n                    render_debug(`Set <${next.tag}> property ${attrName} = ${nAttr}`);\n                    //> We explicitly make a comparison here before setting, because setting reflected\n                    //  HTML properties is _not idempotent_ -- on some elements like audio, video, and iframe,\n                    //  setting properties like src will call a setter that sometimes resets UI state in some\n                    //  browsers. We must compare the new value to DOM directly and not a previous JDOM value,\n                    //  because they differ sometimes when the DOM mutates from under Torus's control, like on a user input.\n                    //  We also guard against cases where the DOM has a default value (like input.type) but\n                    //  we want to still specify a value manually, by checking if `pAttr` was defined.\n                    if (node[attrName] !== nAttr || (pAttr === undefined && pAttr !== nAttr)) {\n                        node[attrName] = nAttr;\n                    }\n                } else {\n                    if (pAttr !== nAttr) {\n                        // @debug\n                        render_debug(`Set <${next.tag}> attribute \"${attrName}\" to \"${nAttr}\"`);\n                        node.setAttribute(attrName, nAttr);\n                    }\n                }\n            }\n\n            //> For any attributes that were removed in the new JDOM,\n            //  also attempt to remove them from the DOM.\n            for (const attrName of Object.keys(previous.attrs)) {\n                if (next.attrs[attrName] === undefined) {\n                    if (attrName in node) {\n                        // @debug\n                        render_debug(`Remove <${next.tag} property ${attrName}`);\n                        //> `null` seems to be the default for most IDL attrs,\n                        //  but even this isn't entirely consistent. This seems\n                        //  like something we should fix as issues come up, not\n                        //  preemptively search for a cross-browser solution.\n                        node[attrName] = null;\n                    } else {\n                        // @debug\n                        render_debug(`Remove <${next.tag}> attribute ${attrName}`);\n                        node.removeAttribute(attrName);\n                    }\n                }\n            }\n\n            diffEvents(next.events, previous.events, (eventName, handlerFn) => {\n                // @debug\n                render_debug(`Set new ${eventName} event listener on <${next.tag}>`);\n                node.addEventListener(eventName, handlerFn);\n            });\n            diffEvents(previous.events, next.events, (eventName, handlerFn) => {\n                // @debug\n                render_debug(`Remove ${eventName} event listener on <${next.tag}>`);\n                node.removeEventListener(eventName, handlerFn);\n            });\n\n            //> Render children recursively. These loops are also well optimized, since\n            //  it's a hot patch of code at runtime.\n            //  We memoize generated child nodes into this `previous._nodes` array\n            //  so we don't have to perform expensive, DOM-touching operations during reconciliation\n            //  to look up children of the current node in the next render pass. `nodeChildren`\n            //  will be updated alongside enqueued DOM mutation operations.\n            //  In the future, we may also look at optimizing more of the common cases of list diffs\n            //  as [domdiff](https://github.com/WebReflection/domdiff/blob/master/esm/index.js) does,\n            //  before delving into a full iterative diff of two lists.\n            const prevChildren = previous.children;\n            const nextChildren = next.children;\n            //> Memoize length lookups.\n            const prevLength = prevChildren.length;\n            const nextLength = nextChildren.length;\n            //> Smaller way to check for \"if either nextLength or prevLength is greater than zero\"\n            if (nextLength + prevLength > 0) {\n                //> Initialize variables we'll need / reference throughout child reconciliation.\n                const nodeChildren = previous._nodes || [];\n                const minLength = prevLength < nextLength ? prevLength : nextLength;\n\n                //> \"sync\" the common sections of the two children lists.\n                let i = 0;\n                for (; i < minLength; i ++) {\n                    if (prevChildren[i] !== nextChildren[i]) {\n                        nodeChildren[i] = render(nodeChildren[i], prevChildren[i], nextChildren[i]);\n                    }\n                }\n                //> If the new JDOM has more children than the old JDOM, we need to\n                //  add the extra children.\n                if (prevLength < nextLength) {\n                    for (; i < nextLength; i ++) {\n                        // @begindebug\n                        if (nextChildren[i].tagName) {\n                            render_debug(`Add child ${printNode(nextChildren[i])}`);\n                        } else if (nextChildren[i].tag) {\n                            render_debug(`Add child ${printNode(nextChildren[i])}`);\n                        } else {\n                            render_debug(`Add child \"${nextChildren[i]}\"`);\n                        }\n                        // @enddebug\n                        const newChild = render(undefined, undefined, nextChildren[i]);\n                        opQueue.push([OP_APPEND, node, newChild]);\n                        nodeChildren.push(newChild);\n                    }\n                //> If the new JDOM has less than or equal number of children to the old\n                //  JDOM, we'll remove any stragglers.\n                } else {\n                    for (; i < prevLength; i ++) {\n                        // @begindebug\n                        if (prevChildren[i].tagName) {\n                            render_debug(`Remove child ${printNode(prevChildren[i])}`);\n                        } else if (prevChildren[i].tag) {\n                            render_debug(`Remove child ${printNode(prevChildren[i])}`);\n                        } else {\n                            render_debug(`Remove child \"${prevChildren[i]}\"`);\n                        }\n                        // @enddebug\n                        //> If we need to remove a child element, removing\n                        //  it from the DOM immediately might lead to race conditions.\n                        //  instead, we add a placeholder and remove the placeholder\n                        //  at the end.\n                        opQueue.push([OP_REMOVE, node, nodeChildren[i]]);\n                    }\n                    nodeChildren.splice(nextLength, prevLength - nextLength);\n                }\n                //> Mount `nodeChildren` onto the up-to-date JDOM, so the next\n                //  render pass can reference it.\n                next._nodes = nodeChildren;\n            }\n        }\n    }\n\n    //> We're done rendering the current node, so decrement the\n    //  render stack counter. If we've reached the top of the\n    //  render tree, it's time to flush replaced nodes to the DOM\n    //  before the next frame.\n    if (-- render_stack === 0) {\n        //> `runDOMOperations()` can also be called completely asynchronously\n        //  with utilities like `requestIdleCallback`, _a la_ Concurrent React,\n        //  for better responsiveness on larger component trees. This requires\n        //  a modification to Torus's architecture, so that each set of `DOMOperations`\n        //  tasks in the `opQueue` from one component's render call are flushed to\n        //  the DOM before the next component's `DOMOperations` begins, for consistency.\n        //  This can be achieved with a nested queue layer on top of `opQueue`.\n        //  Here, we omit concurrency support today because it's not a great necessity\n        //  where Torus is used.\n        runDOMOperations();\n    }\n\n    return node;\n}\n\n//> Shorthand function for the default, empty event object in `Component`.\nconst emptyEvent = () => {\n    return {\n        source: null,\n        handler: () => {},\n    }\n}\n\n//> Torus's Component class\nclass Component {\n\n    constructor(...args) {\n        this.jdom = undefined;\n        this.node = undefined;\n        this.event = emptyEvent();\n        //> We call init() before render, because it's a common pattern\n        //  to set and initialize \"private\" fields in `this.init()` (at least\n        //  before the ES-next private fields proposal becomes widely supported.)\n        //  Frequently, rendering will require private values to be set correctly.\n        this.init(...args);\n        //> After we run `#init()`, we want to make sure that every constructed\n        //  component has a valid `#node` property. To be efficient, we only\n        //  render to set `#node` if it isn't already set yet.\n        if (this.node === undefined) {\n            this.render();\n        }\n    }\n\n    //> `Component.from()` allows us to transform a pure function that\n    //  maps arguments to a JDOM tree, and promote it into a full-fledged\n    //  `Component` class we can compose and use anywhere.\n    static from(fn) {\n        return class FunctionComponent extends Component {\n            init(...args) {\n                this.args = args;\n            }\n            compose() {\n                return fn(...this.args);\n            }\n        }\n    }\n\n    //> The default `Component#init()` is guaranteed to always be a no-op method\n    init() {\n        // should be overridden\n    }\n\n    //> Components usually subscribe to events from a Record, either a view model or\n    //  a model that maps to business logic. This is shorthand to access that.\n    get record() {\n        return this.event.source;\n    }\n\n    bind(source, handler) {\n        this.unbind();\n\n        if (source instanceof Evented) {\n            this.event = {source, handler};\n            source.addHandler(handler);\n        } else {\n            throw new Error(`cannot bind to ${source}, which is not an instance of Evented.`);\n        }\n    }\n\n    unbind() {\n        if (this.record) {\n            this.record.removeHandler(this.event.handler);\n        }\n        this.event = emptyEvent();\n    }\n\n    //> We use `#remove()` to prepare to remove the component from our application\n    // entirely. By default, it unsubscribes from all updates. However, the component\n    // is still in the render tree -- that's something for the user to decide when to\n    //  hide.\n    remove() {\n        this.unbind();\n    }\n\n    //> `#compose()` is our primary rendering API for components. By default, it renders\n    //  an invisible comment node.\n    compose() {\n        return null;\n    }\n\n    //> `#preprocess()` is an API on the component to allow us to extend `Component` to give\n    //  it additional capabilities idiomatically. It consumes the result of `#compose()` and\n    //  returns JDOM to be used to actually render the component. See `Styled()` for a\n    //  usage example.\n    preprocess(jdom) {\n        return jdom;\n    }\n\n    //> `#render()` is called to actually render the component again to the DOM,\n    //  and Torus assumes that it's called rarely, only when the component absolutely\n    //  must update. This obviates the need for something like React's `shouldComponentUpdate`.\n    render(data) {\n        // @debug\n        render_debug(`Render Component: ${this.constructor.name}`, true);\n        data = data || (this.record && this.record.summarize())\n        const jdom = this.preprocess(this.compose(data), data);\n        if (jdom === undefined) {\n            //> If the developer accidentally forgets to return the JDOM value from\n            //  compose, instead of leading to a cryptic DOM API error, show a more\n            //  friendly warning.\n            throw new Error(this.constructor.name + '.compose() returned undefined.');\n        }\n        try {\n            this.node = render(this.node, this.jdom, jdom);\n        } catch (e) {\n            /* istanbul ignore next: haven't found a reproducible error case that triggers this */\n            console.error('rendering error.', e);\n        }\n        return this.jdom = jdom;\n    }\n\n}\n\n//> We keep track of unique class names already injected into the\n//  page's stylesheet, so we don't do redundant style reconciliation.\nconst injectedClassNames = new Set();\n\n//> Global pointer to the stylesheet on the page that Torus uses to insert\n//  new CSS rules. It's set the first time a styled component renders.\nlet styledComponentSheet;\n\n//> A weak (garbage-collected keys) cache for mapping styles objects to hashes\n//  class names. If we use the `css` template tag or cache the styles object\n//  generated in a component in other ways, it's substantially faster to do\n//  a shallow comparison of styles objects and cache unique classnames than\n//  to compare the styles objects deeply every time. This cache implements this\n//  without a huge memory hit in the case of non-cached styles objects, because\n//  `WeakMap`'s keys are garbage collected.\nconst INJECTED_STYLES_CACHE = new WeakMap();\n\n//> Fast hash function to map a style rule to a very reasonably unique class name\n//  that won't conflict with other classes on the page. Checks the styles cache first.\nconst generateUniqueClassName = stylesObject => {\n    if (!INJECTED_STYLES_CACHE.has(stylesObject)) {\n        // Modified from https://github.com/darkskyapp/string-hash/blob/master/index.js\n        const str = JSON.stringify(stylesObject);\n        let i = str.length;\n        let hash = 1989;\n        while (i) {\n            hash = (hash * 13) ^ str.charCodeAt(-- i);\n        }\n        INJECTED_STYLES_CACHE.set(stylesObject, '_torus' + (hash >>> 0));\n    }\n    return INJECTED_STYLES_CACHE.get(stylesObject);\n}\n\n//> We have to construct lots of a{b} syntax in CSS, so here's a shorthand.\nconst brace = (a, b) => a + '{' + b + '}';\n\n//> The meat of `Styled()`. This function maps an ergonomic, dictionary-based\n//  set of CSS declarations to an array of CSS rules that can be inserted onto\n//  the page stylesheet, and recursively resolves nested CSS, handles keyframes\n//  and media queries, and parses other SCSS-like things.\nconst rulesFromStylesObject = (selector, stylesObject) => {\n    let rules = [];\n    let selfDeclarations = '';\n    for (const prop of Object.keys(stylesObject)) {\n        const val = stylesObject[prop];\n        //> CSS declarations that start with '@' are globally namespaced\n        //  (like @keyframes and @media), so we need to treat them differently.\n        if (prop[0] === '@') {\n            if (prop.startsWith('@media')) {\n                rules.push(brace(prop, rulesFromStylesObject(selector, val).join('')));\n            } else  { // @keyframes or @font-face\n                rules.push(brace(prop, rulesFromStylesObject('', val).join('')));\n            }\n        } else {\n            if (typeof val === 'object') {\n                const commaSeparatedProps = prop.split(',');\n                for (const p of commaSeparatedProps) {\n                    //> SCSS-like syntax means we use '&' to nest declarations about\n                    //  the parent selector.\n                    if (p.includes('&')) {\n                        const fullSelector = p.replace(/&/g, selector);\n                        rules = rules.concat(rulesFromStylesObject(fullSelector, val));\n                    } else {\n                        rules = rules.concat(rulesFromStylesObject(selector + ' ' + p, val));\n                    }\n                }\n            } else {\n                selfDeclarations += prop + ':' + val + ';';\n            }\n        }\n    }\n    if (selfDeclarations) {\n        //> We unshift the self declarations to the beginning of the list of rules\n        //  instead of simply pushing it to the end, because we want the nested rules\n        //  to have precedence / override rules on self.\n        rules.unshift(brace(selector, selfDeclarations));\n    }\n\n    return rules;\n}\n\n//> Function called once to initialize a stylesheet for Torus\n//  to use on every subsequent style render.\nconst initSheet = () => {\n    const styleElement = document.createElement('style');\n    styleElement.setAttribute('data-torus', '');\n    document.head.appendChild(styleElement);\n    styledComponentSheet = styleElement.sheet;\n}\n\n//> The preprocessor on `Styled()` components call this to\n//  make sure a given set of CSS rules for a component is inserted\n//  into the page stylesheet, but only once for a unique set of rules.\n//  We disambiguate by the class name, which is a hash of the CSS rules.\nconst injectStylesOnce = stylesObject => {\n    const className = generateUniqueClassName(stylesObject);\n    let sheetLength = 0;\n    if (!injectedClassNames.has(className)) {\n        if (!styledComponentSheet) {\n            initSheet();\n        }\n        const rules = rulesFromStylesObject('.' + className, stylesObject);\n        for (const rule of rules) {\n            // @debug\n            render_debug(`Add new CSS rule: ${rule}`);\n            styledComponentSheet.insertRule(rule, sheetLength ++);\n        }\n        injectedClassNames.add(className);\n    }\n    return className;\n}\n\n//> Higher-order component to enable styling for any Component class.\nconst Styled = Base => {\n    return class extends Base {\n        //> In a styled component, the `#styles()` method is passed in\n        //  the same data as `#compose()`, and returns a JSON of nested CSS.\n        styles() {\n            return {};\n        }\n\n        preprocess(jdom, data) {\n            if (isObject(jdom)) {\n                jdom.attrs = jdom.attrs || {};\n                jdom.attrs.class = arrayNormalize(jdom.attrs.class || []);\n                jdom.attrs.class.push(injectStylesOnce(this.styles(data)));\n            }\n            return jdom;\n        }\n    }\n}\n\n//> Torus's generic List implementation, based on Stores.\n//  React and similar virtual-dom view libraries depend on [key-based\n//  reconciliation](https://reactjs.org/docs/reconciliation.html) during render\n//  to efficiently render children of long lists. Torus doesn't (yet) have a key-aware\n//  reconciler in the diffing algorithm, but `List`'s design obviates the need for keys.\n//  Rather than giving the renderer a flat virtual DOM tree to render, `List`\n//  instantiates each individual item component and hands them off to the renderer as full\n//  DOM Node elements, so each list item manages its own rendering, and the list component\n//  only worries about displaying the list wrapper and a flat list of children items.\n\nclass List extends Component {\n\n    get itemClass() {\n        return Component; // default value, should be overridden\n    }\n\n    init(store, ...itemData) {\n        this.store = store;\n        this.items = new Map();\n        this.filterFn = null;\n        this.itemData = itemData;\n\n        this.bind(this.store, () => this.itemsChanged());\n    }\n\n    itemsChanged() {\n        //> For every record in the store, if it isn't already in\n        //  `this.items`, add it and its view; if any were removed,\n        //  also remove it from `this.items`.\n        const data = this.store.summarize();\n        const items = this.items;\n        for (const record of items.keys()) {\n            if (!data.includes(record)) {\n                items.get(record).remove();\n                items.delete(record);\n            }\n        }\n        for (const record of data) {\n            if (!items.has(record)) {\n                items.set(\n                    record,\n                    //> We pass a callback that takes a record and removes it from\n                    //  the list's store. It's common in UIs for items to have a button\n                    //  that removes the item from the list, so this callback is passed\n                    //  to the item component constructor to facilitate that pattern.\n                    new this.itemClass(\n                        record,\n                        () => this.store.remove(record),\n                        ...this.itemData\n                    )\n                );\n            }\n        }\n\n        let sorter = [...items.entries()];\n        //> Sort by the provided filter function if there is one\n        if (this.filterFn !== null) {\n            sorter = sorter.filter(item => this.filterFn(item[0]));\n        }\n        //> Sort the list the way the associated Store is sorted.\n        sorter.sort((a, b) => data.indexOf(a[0]) - data.indexOf(b[0]));\n\n        //> Store the new items in a new (insertion-ordered) Map at this.items\n        this.items = new Map(sorter);\n\n        this.render();\n    }\n\n    filter(filterFn) {\n        this.filterFn = filterFn;\n        this.itemsChanged();\n    }\n\n    unfilter() {\n        this.filterFn = null;\n        this.itemsChanged();\n    }\n\n    get components() {\n        return [...this];\n    }\n\n    //> `List#nodes` returns the HTML nodes for each of its item\n    //  views, sorted in order. Designed to make writing `#compose()` easier.\n    get nodes() {\n        return this.components.map(item => item.node);\n    }\n\n    //> This iterator is called when JavaScript requests an iterator from a list,\n    //  e.g. when `for (const _ of someList)` is run.\n    [Symbol.iterator]() {\n        return this.items.values();\n    }\n\n    remove() {\n        super.remove();\n        //> When we remove a list, we also want to call `remove()` on each\n        //  child components.\n        for (const c of this.items.values()) {\n            c.remove();\n        }\n    }\n\n    //> By default, just render the children views in a `<ul/>`\n    compose() {\n        return {\n            tag: 'ul',\n            children: this.nodes,\n        }\n    }\n\n}\n\n//> Higher-order component to create a list component for a given\n//  child item component.\nconst ListOf = itemClass => {\n    return class extends List {\n        get itemClass() {\n            return itemClass;\n        }\n    }\n}\n\n//> A base class for evented data stores. Not exposed to the public API, but\n//  all observables in Torus inherit from `Evented`.\nclass Evented {\n\n    constructor() {\n        this.handlers = new Set();\n    }\n\n    //> Base, empty implementation of `#summarize()` which is overridden in all subclasses.\n    //  In subclasses, this returns the \"summary\" of the current state of the\n    //  event emitter as an object/array.\n    summarize /* istanbul ignore next */ () {}\n\n    //> Whenever something changes, we fire an event to all subscribed\n    //  listeners, with a summary of its state.\n    emitEvent() {\n        const summary = this.summarize();\n        for (const handler of this.handlers) {\n            handler(summary);\n        }\n    }\n\n    addHandler(handler) {\n        this.handlers.add(handler);\n        handler(this.summarize());\n    }\n\n    removeHandler(handler) {\n        this.handlers.delete(handler);\n    }\n\n}\n\n//> `Record` is Torus's unit of individual data source, used for view models and\n//  Models from business logic.\nclass Record extends Evented {\n\n    constructor(id, data = {}) {\n        super();\n\n        //> We can create a Record by either passing in just the properties,\n        //  or an ID and a dictionary of props. We disambiguate here.\n        if (isObject(id)) {\n            data = id;\n            id = null;\n        }\n\n        this.id = id;\n        this.data = data;\n    }\n\n    //> Setter for properties\n    update(data) {\n        Object.assign(this.data, data);\n        this.emitEvent();\n    }\n\n    //> Getter\n    get(name) {\n        return this.data[name];\n    }\n\n    //> We summarize a Record by returning a dictionary of\n    //  all of its properties and the ID\n    summarize() {\n        return Object.assign(\n            {id: this.id},\n            this.data\n        );\n    }\n\n    //> The JSON-serialized version of a Record is the same as its\n    //  summary, since it's a shallow data store with just plain properties.\n    serialize() {\n        return this.summarize();\n    }\n\n}\n\n//> A list of Records, represents a collection or a table\nclass Store extends Evented {\n\n    constructor(records = []) {\n        super();\n        //> Reset the store's contents with the given records\n        this.reset(records);\n    }\n\n    get recordClass() {\n        return Record;\n    }\n\n    get comparator() {\n        return null;\n    }\n\n    //> Create and return a new instance of the store's record from\n    //  the given data.\n    create(id, data) {\n        return this.add(new this.recordClass(id, data));\n    }\n\n    //> Add a given record to this store, also called by `#create()`.\n    add(record) {\n        this.records.add(record);\n        this.emitEvent();\n        return record;\n    }\n\n    //> Remove a given record from the store.\n    remove(record) {\n        this.records.delete(record);\n        this.emitEvent();\n        return record;\n    }\n\n    //> This iterator is called when JavaScript requests an iterator from a store,\n    //  like when `for (const _ of someStore)` is run.\n    [Symbol.iterator]() {\n        return this.records.values();\n    }\n\n    //> Try to find a record with the given ID in the store,\n    //  and return it. Returns null if not found.\n    find(id) {\n        for (const record of this.records) {\n            if (record.id === id) {\n                return record;\n            }\n        }\n        return null;\n    }\n\n    reset(records) {\n        //> Internally, we represent the store as an unordered set.\n        //  we only order by comparator when we summarize. This prevents\n        //  us from having to perform sorting checks on every insert/update,\n        //  and is efficient as long as we don't re-render excessively.\n        this.records = new Set(records);\n        this.emitEvent();\n    }\n\n    summarize() {\n        //> The summary of a store is defined functionally. We just sort\n        //  the records in our store by the comparator (but we use a list\n        //  of pairs of cached comparators and records to be fast.\n        return [...this.records].map(record => [\n            this.comparator ? this.comparator(record) : null,\n            record,\n        ]).sort((a, b) => {\n            if (a[0] < b[0]) {\n                return -1;\n            } else if (a[0] > b[0]) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }).map(o => o[1]);\n    }\n\n    //> To serialize a store, we serialize each record and put them\n    //  in a giant list.\n    serialize() {\n        return this.summarize().map(record => record.serialize());\n    }\n\n}\n\n//> Higher-order component to create a Store for a given\n//  record class.\nconst StoreOf = recordClass => {\n    return class extends Store {\n        get recordClass() {\n            return recordClass;\n        }\n    }\n}\n\n//> Helper function for the router. It takes a route string\n//  that contains parameters like, `/path/:param1/path/:param2`\n//  and returns a regular expression to match that route\n//  and a list of params in that route.\nconst routeStringToRegExp = route => {\n    let match;\n    const paramNames = [];\n    while (match !== null) {\n        match = (/:\\w+/).exec(route);\n        if (match) {\n            const paramName = match[0];\n            paramNames.push(paramName.substr(1));\n            route = route.replace(paramName, '(.+)');\n        }\n    }\n    return [new RegExp(route), paramNames];\n}\n\n//> Front-end router. A routing component can bind\n//  to updates from the Router instead of a Record, and re-render\n//  different subviews when the routes change.\nclass Router extends Evented {\n\n    constructor(routes) {\n        super();\n        //> We parse the given dictionary of routes into three things:\n        //  the name of the route, the route regular expression, and\n        //  the list of params in that route.\n        this.routes = Object.entries(routes)\n            .map(([name, route]) => [name, ...routeStringToRegExp(route)]);\n        //> Last matched route's information is cached here\n        this.lastMatch = ['', null];\n        //> Whenever the browser pops the history state (i.e. when the user\n        //  goes back with the back button or forward with the forward button),\n        //  we need to route again.\n        this._cb = () => this.route(location.pathname);\n        window.addEventListener('popstate', this._cb);\n        //> Route the current URL, if it's already a deep link to a path.\n        this._cb();\n    }\n\n    //> The \"summary\" of this Evented (components can bind to this object)\n    //  is the information about the last route.\n    summarize() {\n        return this.lastMatch;\n    }\n\n    //> Click events from links can call `this.go()` with the destination URL\n    //  to trigger going to a new route without reloading the page. New routes\n    //  are only added to the session history if the route is indeed new.\n    go(destination, {replace = false} = {}) {\n        if (window.location.pathname !== destination) {\n            if (replace) {\n                history.replaceState(null, document.title, destination);\n            } else {\n                history.pushState(null, document.title, destination);\n            }\n            this.route(destination);\n        }\n    }\n\n    //> Main procedure to reconcile which of the defined route the current\n    //  location path matches, and dispatch the right event. Routes are checked\n    //  in order of declaration.\n    route(path) {\n        //> Match destination against the route regular expressions\n        for (const [name, routeRe, paramNames] of this.routes) {\n            const match = routeRe.exec(path);\n            if (match !== null) {\n                const result = {};\n                const paramValues = match.slice(1);\n                //> Given the matched values and parameter names,\n                //  build a dictionary of params that components can use\n                //  to re-render based on the route.\n                paramNames.forEach((name, i) => result[name] = paramValues[i]);\n                this.lastMatch = [name, result];\n                break;\n            }\n        }\n        this.emitEvent();\n    }\n\n    //> When we don't want the router to work anymore / stop listening / be gc'd,\n    //  we can call `#remove()` to do just that.\n    remove() {\n        window.removeEventListener('popstate', this._cb);\n    }\n\n}\n\n//> Torus exposes these public APIs\nconst exposedNames = {\n    //> `render` isn't designed to be a public API and the API\n    //  might change, but it's exposed to make unit testing easier.\n    render,\n    Component,\n    Styled,\n    //> Provide a default, `StyledComponent` class.\n    StyledComponent: Styled(Component),\n    List,\n    ListOf,\n    Record,\n    Store,\n    StoreOf,\n    Router,\n}\n\n//> If there is a global `window` object, bind API names to it.\n/* istanbul ignore else */\nif (typeof window === 'object') {\n    window.Torus = exposedNames;\n}\n//> Export public APIs CommonJS-style\n/* istanbul ignore next */\nif ( true && module.exports) {\n    module.exports = exposedNames;\n}\n\n\n//# sourceURL=webpack://torus-dom/./src/torus.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/torus.js");
/******/ 	
/******/ })()
;